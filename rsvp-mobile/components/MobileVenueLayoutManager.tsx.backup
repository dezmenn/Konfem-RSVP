import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  PanResponder,
  Animated,
  StyleSheet,
  Dimensions,
  Alert,
  Modal,
  TextInput,
  FlatList,
  Platform,
} from 'react-native';
import { VenueElement, Position, Dimensions as VenueDimensions, Table } from '../types';

interface MobileVenueLayoutManagerProps {
  eventId: string;
  onElementSelect?: (element: VenueElement | null) => void;
  onTableSelect?: (table: Table | null) => void;
  onLayoutChange?: (elements: VenueElement[], tables: Table[]) => void;
}

interface VenueElementLibraryItem {
  type: VenueElement['type'];
  name: string;
  defaultDimensions: VenueDimensions;
  defaultColor: string;
  description: string;
  icon: string;
}

interface GestureState {
  scale: number;
  translateX: number;
  translateY: number;
  isGesturing: boolean;
}

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');
const MIN_SCALE = 0.5;
const MAX_SCALE = 3.0;
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;

const MobileVenueLayoutManager: React.FC<MobileVenueLayoutManagerProps> = ({
  eventId,
  onElementSelect,
  onTableSelect,
  onLayoutChange
}) => {
  const [elements, setElements] = useState<VenueElement[]>([]);
  const [tables, setTables] = useState<Table[]>([]);
  const [selectedItem, setSelectedItem] = useState<{ type: 'element' | 'table'; item: VenueElement | Table } | null>(null);
  const [showLibrary, setShowLibrary] = useState(false);
  const [showProperties, setShowProperties] = useState(false);
  const [gestureState, setGestureState] = useState<GestureState>({
    scale: 1,
    translateX: 0,
    translateY: 0,
    isGesturing: false
  });

  // Animation values
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const translateXAnim = useRef(new Animated.Value(0)).current;
  const translateYAnim = useRef(new Animated.Value(0)).current;

  // Library data
  const [library] = useState<VenueElementLibraryItem[]>([
    {
      type: 'stage',
      name: 'Stage',
      defaultDimensions: { width: 120, height: 80 },
      defaultColor: '#8e24aa',
      description: 'Main stage area',
      icon: 'üé≠'
    },
    {
      type: 'dance_floor',
      name: 'Dance Floor',
      defaultDimensions: { width: 100, height: 100 },
      defaultColor: '#1976d2',
      description: 'Dance floor area',
      icon: 'üíÉ'
    },
    {
      type: 'bar',
      name: 'Bar',
      defaultDimensions: { width: 80, height: 40 },
      defaultColor: '#d32f2f',
      description: 'Bar counter',
      icon: 'üç∏'
    },
    {
      type: 'entrance',
      name: 'Entrance',
      defaultDimensions: { width: 60, height: 20 },
      defaultColor: '#388e3c',
      description: 'Main entrance',
      icon: 'üö™'
    },
    {
      type: 'walkway',
      name: 'Walkway',
      defaultDimensions: { width: 200, height: 30 },
      defaultColor: '#795548',
      description: 'Walking path',
      icon: 'üõ§Ô∏è'
    },
    {
      type: 'decoration',
      name: 'Decoration',
      defaultDimensions: { width: 40, height: 40 },
      defaultColor: '#ff9800',
      description: 'Decorative element',
      icon: 'üå∏'
    }
  ]);

  useEffect(() => {
    loadData();
  }, [eventId]);

  useEffect(() => {
    // Listen for dimension changes for responsive scaling
    const subscription = Dimensions.addEventListener('change', ({ window }) => {
      setGestureState(prev => ({
        ...prev,
        scale: Math.min(prev.scale, MAX_SCALE * (window.width / screenWidth))
      }));
    });

    return () => subscription?.remove();
  }, []);

  const loadData = async () => {
    await Promise.all([
      loadVenueLayout(),
      loadTables()
    ]);
  };

  const loadVenueLayout = async () => {
    try {
      const response = await fetch(`/api/venue-layout/events/${eventId}`);
      if (response.ok) {
        const data = await response.json();
        setElements(data.elements || []);
      }
    } catch (error) {
      console.error('Error loading venue layout:', error);
    }
  };

  const loadTables = async () => {
    try {
      const response = await fetch(`/api/tables/events/${eventId}`);
      if (response.ok) {
        const data = await response.json();
        setTables(data || []);
      }
    } catch (error) {
      console.error('Error loading tables:', error);
    }
  };

  // Gesture handling
  const createPanResponder = () => {
    let lastScale = 1;
    let lastTranslateX = 0;
    let lastTranslateY = 0;

    return PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: () => true,

      onPanResponderGrant: () => {
        setGestureState(prev => ({ ...prev, isGesturing: true }));
        lastScale = gestureState.scale;
        lastTranslateX = gestureState.translateX;
        lastTranslateY = gestureState.translateY;
      },

      onPanResponderMove: (evt, gestureState) => {
        if (evt.nativeEvent.touches.length === 2) {
          // Pinch to zoom
          const touch1 = evt.nativeEvent.touches[0];
          const touch2 = evt.nativeEvent.touches[1];
          
          const distance = Math.sqrt(
            Math.pow(touch2.pageX - touch1.pageX, 2) + 
            Math.pow(touch2.pageY - touch1.pageY, 2)
          );
          
          // Simple scale calculation (you might want to improve this)
          const scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, lastScale * (distance / 200)));
          
          setGestureState(prev => ({ ...prev, scale }));
          scaleAnim.setValue(scale);
        } else {
          // Pan
          const newTranslateX = lastTranslateX + gestureState.dx;
          const newTranslateY = lastTranslateY + gestureState.dy;
          
          setGestureState(prev => ({
            ...prev,
            translateX: newTranslateX,
            translateY: newTranslateY
          }));
          
          translateXAnim.setValue(newTranslateX);
          translateYAnim.setValue(newTranslateY);
        }
      },

      onPanResponderRelease: () => {
        setGestureState(prev => ({ ...prev, isGesturing: false }));
      },
    });
  };

  const panResponder = createPanResponder();

  const resetView = () => {
    const newState = { scale: 1, translateX: 0, translateY: 0, isGesturing: false };
    setGestureState(newState);
    
    Animated.parallel([
      Animated.spring(scaleAnim, { toValue: 1, useNativeDriver: true }),
      Animated.spring(translateXAnim, { toValue: 0, useNativeDriver: true }),
      Animated.spring(translateYAnim, { toValue: 0, useNativeDriver: true }),
    ]).start();
  };

  const zoomIn = () => {
    const newScale = Math.min(MAX_SCALE, gestureState.scale * 1.5);
    setGestureState(prev => ({ ...prev, scale: newScale }));
    Animated.spring(scaleAnim, { toValue: newScale, useNativeDriver: true }).start();
  };

  const zoomOut = () => {
    const newScale = Math.max(MIN_SCALE, gestureState.scale / 1.5);
    setGestureState(prev => ({ ...prev, scale: newScale }));
    Animated.spring(scaleAnim, { toValue: newScale, useNativeDriver: true }).start();
  };

  const createElementFromLibrary = async (libraryItem: VenueElementLibraryItem) => {
    try {
      // Place element at center of visible area
      const centerX = (screenWidth / 2 - gestureState.translateX) / gestureState.scale;
      const centerY = (screenHeight / 2 - gestureState.translateY) / gestureState.scale;
      
      const response = await fetch(`/api/venue-layout/events/${eventId}/elements`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: libraryItem.type,
          name: libraryItem.name,
          position: { x: centerX, y: centerY },
          dimensions: libraryItem.defaultDimensions,
          color: libraryItem.defaultColor
        })
      });

      if (response.ok) {
        const newElement = await response.json();
        const updatedElements = [...elements, newElement];
        setElements(updatedElements);
        onLayoutChange?.(updatedElements, tables);
        setShowLibrary(false);
        Alert.alert('Success', `${libraryItem.name} added to venue`);
      }
    } catch (error) {
      console.error('Error creating element:', error);
      Alert.alert('Error', 'Failed to create element');
    }
  };

  const deleteElement = async (elementId: string) => {
    Alert.alert(
      'Delete Element',
      'Are you sure you want to delete this element?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              const response = await fetch(`/api/venue-layout/elements/${elementId}`, {
                method: 'DELETE'
              });

              if (response.ok) {
                const updatedElements = elements.filter(el => el.id !== elementId);
                setElements(updatedElements);
                onLayoutChange?.(updatedElements, tables);
                
                if (selectedItem?.type === 'element' && (selectedItem.item as VenueElement).id === elementId) {
                  setSelectedItem(null);
                  onElementSelect?.(null);
                  setShowProperties(false);
                }
                
                Alert.alert('Success', 'Element deleted');
              }
            } catch (error) {
              console.error('Error deleting element:', error);
              Alert.alert('Error', 'Failed to delete element');
            }
          }
        }
      ]
    );
  };

  const handleItemPress = (item: VenueElement | Table, type: 'element' | 'table') => {
    setSelectedItem({ type, item });
    if (type === 'element') {
      onElementSelect?.(item as VenueElement);
    } else {
      onTableSelect?.(item as Table);
    }
    setShowProperties(true);
  };

  const renderElement = (element: VenueElement) => {
    const isSelected = selectedItem?.type === 'element' && selectedItem.item.id === element.id;
    
    return (
      <TouchableOpacity
        key={element.id}
        style={[
          styles.venueElement,
          {
            left: element.position.x,
            top: element.position.y,
            width: element.dimensions.width,
            height: element.dimensions.height,
            backgroundColor: element.color,
          },
          isSelected && styles.selectedElement
        ]}
        onPress={() => handleItemPress(element, 'element')}
        activeOpacity={0.7}
      >
        <Text style={styles.elementLabel} numberOfLines={2}>
          {element.name}
        </Text>
      </TouchableOpacity>
    );
  };

  const renderTable = (table: Table) => {
    const isSelected = selectedItem?.type === 'table' && (selectedItem.item as Table).id === table.id;
    
    return (
      <TouchableOpacity
        key={table.id}
        style={[
          styles.venueTable,
          {
            left: table.position.x,
            top: table.position.y,
          },
          isSelected && styles.selectedTable,
          table.isLocked && styles.lockedTable
        ]}
        onPress={() => handleItemPress(table, 'table')}
        activeOpacity={0.7}
      >
        <Text style={styles.tableLabel} numberOfLines={1}>
          {table.name}
        </Text>
        <Text style={styles.tableCapacity}>
          {table.capacity}{table.isLocked && ' üîí'}
        </Text>
      </TouchableOpacity>
    );
  };

  const renderLibraryItem = ({ item }: { item: VenueElementLibraryItem }) => (
    <TouchableOpacity
      style={styles.libraryItem}
      onPress={() => createElementFromLibrary(item)}
      activeOpacity={0.7}
    >
      <Text style={styles.libraryIcon}>{item.icon}</Text>
      <View style={styles.libraryItemText}>
        <Text style={styles.libraryName}>{item.name}</Text>
        <Text style={styles.libraryDescription}>{item.description}</Text>
      </View>
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      {/* Toolbar */}
      <View style={styles.toolbar}>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.toolbarContent}
        >
          <TouchableOpacity
            style={styles.toolbarButton}
            onPress={() => setShowLibrary(true)}
          >
            <Text style={styles.toolbarButtonText}>üìö Library</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.toolbarButton}
            onPress={zoomOut}
          >
            <Text style={styles.toolbarButtonText}>üîç-</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.toolbarButton}
            onPress={resetView}
          >
            <Text style={styles.toolbarButtonText}>üéØ Reset</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.toolbarButton}
            onPress={zoomIn}
          >
            <Text style={styles.toolbarButtonText}>üîç+</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.toolbarButton}
            onPress={loadData}
          >
            <Text style={styles.toolbarButtonText}>üîÑ Refresh</Text>
          </TouchableOpacity>
        </ScrollView>
        
        <Text style={styles.zoomIndicator}>
          {Math.round(gestureState.scale * 100)}%
        </Text>
      </View>

      {/* Canvas */}
      <View style={styles.canvasContainer}>
        <Animated.View
          {...panResponder.panHandlers}
          style={[
            styles.canvas,
            {
              width: CANVAS_WIDTH,
              height: CANVAS_HEIGHT,
              transform: [
                { scale: scaleAnim },
                { translateX: translateXAnim },
                { translateY: translateYAnim },
              ],
            }
          ]}
        >
          {/* Grid background */}
          <View style={styles.grid} />
          
          {/* Venue elements */}
          {elements.map(renderElement)}
          
          {/* Tables */}
          {tables.map(renderTable)}
        </Animated.View>
      </View>

      {/* Element Library Modal */}
      <Modal
        visible={showLibrary}
        animationType="slide"
        presentationStyle="pageSheet"
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Venue Element Library</Text>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setShowLibrary(false)}
            >
              <Text style={styles.closeButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
          
          <Text style={styles.modalSubtitle}>
            Tap any element to add it to your venue layout
          </Text>
          
          <FlatList
            data={library}
            renderItem={renderLibraryItem}
            keyExtractor={(item) => item.type}
            style={styles.libraryList}
            numColumns={2}
            columnWrapperStyle={styles.libraryRow}
          />
        </View>
      </Modal>

      {/* Properties Modal */}
      <Modal
        visible={showProperties && selectedItem !== null}
        animationType="slide"
        presentationStyle="pageSheet"
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>
              {selectedItem?.type === 'element' ? 'Element' : 'Table'} Properties
            </Text>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setShowProperties(false)}
            >
              <Text style={styles.closeButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
          
          {selectedItem && (
            <ScrollView style={styles.propertiesContainer}>
              <View style={styles.propertyGroup}>
                <Text style={styles.propertyLabel}>Name:</Text>
                <Text style={styles.propertyValue}>{selectedItem.item.name}</Text>
              </View>

              {selectedItem.type === 'element' && (
                <>
                  <View style={styles.propertyGroup}>
                    <Text style={styles.propertyLabel}>Type:</Text>
                    <Text style={styles.propertyValue}>
                      {(selectedItem.item as VenueElement).type}
                    </Text>
                  </View>
                  
                  <View style={styles.propertyGroup}>
                    <Text style={styles.propertyLabel}>Position:</Text>
                    <Text style={styles.propertyValue}>
                      X: {Math.round((selectedItem.item as VenueElement).position.x)}, 
                      Y: {Math.round((selectedItem.item as VenueElement).position.y)}
                    </Text>
                  </View>
                  
                  <View style={styles.propertyGroup}>
                    <Text style={styles.propertyLabel}>Size:</Text>
                    <Text style={styles.propertyValue}>
                      {Math.round((selectedItem.item as VenueElement).dimensions.width)} √ó 
                      {Math.round((selectedItem.item as VenueElement).dimensions.height)}
                    </Text>
                  </View>
                </>
              )}

              {selectedItem.type === 'table' && (
                <>
                  <View style={styles.propertyGroup}>
                    <Text style={styles.propertyLabel}>Capacity:</Text>
                    <Text style={styles.propertyValue}>
                      {(selectedItem.item as Table).capacity} seats
                    </Text>
                  </View>
                  
                  <View style={styles.propertyGroup}>
                    <Text style={styles.propertyLabel}>Position:</Text>
                    <Text style={styles.propertyValue}>
                      X: {Math.round((selectedItem.item as Table).position.x)}, 
                      Y: {Math.round((selectedItem.item as Table).position.y)}
                    </Text>
                  </View>
                  
                  <View style={styles.propertyGroup}>
                    <Text style={styles.propertyLabel}>Status:</Text>
                    <Text style={styles.propertyValue}>
                      {(selectedItem.item as Table).isLocked ? 'Locked üîí' : 'Unlocked üîì'}
                    </Text>
                  </View>
                </>
              )}

              <View style={styles.propertyActions}>
                {selectedItem.type === 'element' && (
                  <TouchableOpacity
                    style={[styles.actionButton, styles.deleteButton]}
                    onPress={() => deleteElement(selectedItem.item.id)}
                  >
                    <Text style={styles.deleteButtonText}>Delete Element</Text>
                  </TouchableOpacity>
                )}
              </View>
            </ScrollView>
          )}
        </View>
      </Modal>

      {/* Gesture Instructions */}
      {!gestureState.isGesturing && elements.length === 0 && tables.length === 0 && (
        <View style={styles.instructionsOverlay}>
          <Text style={styles.instructionsTitle}>Getting Started</Text>
          <Text style={styles.instructionsText}>
            ‚Ä¢ Tap "Library" to add venue elements{'\n'}
            ‚Ä¢ Pinch to zoom in/out{'\n'}
            ‚Ä¢ Drag to pan around{'\n'}
            ‚Ä¢ Tap elements to select and edit
          </Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  toolbar: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 4,
      },
    }),
  },
  toolbarContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  toolbarButton: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 6,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  toolbarButtonText: {
    fontSize: 12,
    color: '#333',
    fontWeight: '500',
  },
  zoomIndicator: {
    marginLeft: 'auto',
    fontSize: 12,
    color: '#666',
    fontWeight: '500',
    paddingHorizontal: 8,
  },
  canvasContainer: {
    flex: 1,
    backgroundColor: '#f9f9f9',
    alignItems: 'center',
    justifyContent: 'center',
  },
  canvas: {
    backgroundColor: 'white',
    borderWidth: 2,
    borderColor: '#ddd',
    borderRadius: 8,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 8,
      },
      android: {
        elevation: 5,
      },
    }),
  },
  grid: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'transparent',
    // Add grid pattern if needed
  },
  venueElement: {
    position: 'absolute',
    borderRadius: 4,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.1)',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  selectedElement: {
    borderColor: '#2196F3',
    borderWidth: 2,
  },
  elementLabel: {
    fontSize: 10,
    fontWeight: '500',
    color: 'white',
    textAlign: 'center',
    textShadowColor: 'rgba(0,0,0,0.5)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
    paddingHorizontal: 4,
    paddingVertical: 2,
  },
  venueTable: {
    position: 'absolute',
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#8bc34a',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#689f38',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 3,
      },
    }),
  },
  selectedTable: {
    borderColor: '#2196F3',
    borderWidth: 3,
  },
  lockedTable: {
    backgroundColor: '#9e9e9e',
    borderColor: '#616161',
  },
  tableLabel: {
    fontSize: 10,
    fontWeight: 'bold',
    color: 'white',
    textAlign: 'center',
  },
  tableCapacity: {
    fontSize: 8,
    color: 'white',
    textAlign: 'center',
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'white',
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    backgroundColor: '#f8f9fa',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  modalSubtitle: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    padding: 16,
    backgroundColor: '#f8f9fa',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  closeButton: {
    backgroundColor: '#2196F3',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 6,
  },
  closeButtonText: {
    color: 'white',
    fontWeight: '500',
  },
  libraryList: {
    flex: 1,
    padding: 16,
  },
  libraryRow: {
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  libraryItem: {
    flex: 0.48,
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  libraryIcon: {
    fontSize: 24,
    marginRight: 12,
  },
  libraryItemText: {
    flex: 1,
  },
  libraryName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  libraryDescription: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  propertiesContainer: {
    flex: 1,
    padding: 16,
  },
  propertyGroup: {
    marginBottom: 16,
  },
  propertyLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginBottom: 4,
  },
  propertyValue: {
    fontSize: 14,
    color: '#666',
    padding: 12,
    backgroundColor: '#f8f9fa',
    borderRadius: 6,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  propertyActions: {
    marginTop: 24,
  },
  actionButton: {
    padding: 16,
    borderRadius: 6,
    alignItems: 'center',
    marginBottom: 12,
  },
  deleteButton: {
    backgroundColor: '#f44336',
  },
  deleteButtonText: {
    color: 'white',
    fontWeight: '500',
    fontSize: 16,
  },
  instructionsOverlay: {
    position: 'absolute',
    top: '40%',
    left: 20,
    right: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    padding: 20,
    borderRadius: 12,
    alignItems: 'center',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 8,
      },
      android: {
        elevation: 5,
      },
    }),
  },
  instructionsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
  },
  instructionsText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    lineHeight: 20,
  },
});

export default MobileVenueLayoutManager;